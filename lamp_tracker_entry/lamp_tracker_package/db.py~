from trastr_package import app, login_manager
from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
from flask_bcrypt import Bcrypt
from geoalchemy2.types import Geography
from sqlalchemy import inspect, event, text
from sqlalchemy.sql.expression import and_
from datetime import datetime
from flask_migrate import Migrate

db = SQLAlchemy(app)
bcrypt = Bcrypt(app)
migrate = Migrate(app, db)

def database_is_empty():
    engine = db.get_engine(app)
    table_names = inspect(engine).get_table_names()
    is_empty = table_names == []
    return is_empty


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

class User(db.Model, UserMixin):
    id = db.Column(db.BigInteger, primary_key=True)
    password = db.Column(db.Unicode(200), nullable=False)
    name = db.Column(db.Unicode)
    email = db.Column(db.Unicode(200), nullable=False)

class AccessRole(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode, unique=True)
    permissions = db.relationship(
        "Permission", secondary=access_role_permission, backref="access_roles"
    )


class Permission(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode, unique=True)


class Product(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    product_versions = db.relationship("ProductVersion", backref="product", order_by="ProductVersion.change_dtm.desc()")
    prices = db.relationship("Price", backref="product", order_by="Price.change_dtm.desc()")


class ProductVersion(db.Model):
    product_id = db.Column(db.BigInteger, db.ForeignKey("product.id"), primary_key=True)
    change_dtm = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, primary_key=True)
    user_id = db.Column(db.BigInteger, db.ForeignKey("user.id"), nullable=False)
    # barcode is for storing the numerical result of scanning the primary barcode
    # on the product. It does not need to be a GTIN, EAN, or anything like that.
    barcode = db.Column(db.BigInteger)
    category_id = db.Column(db.BigInteger, db.ForeignKey("product_category.id"))
    name = db.Column(db.Unicode(80))
    brand_id = db.Column(db.BigInteger, db.ForeignKey("product_brand.id"))
    #    maybe have separate volume and mass fields
    magnitude = db.Column(db.Float)
    magnitude_unit_id = db.Column(db.BigInteger, db.ForeignKey("magnitude_unit.id"))
    local_image_filename = db.Column(db.Unicode(20))
    remote_image_url = db.Column(db.Unicode(300))
    open_food_facts_categories = db.relationship(
        "OpenFoodFactsCategory", secondary=product_version_open_food_facts_category, backref="products"
    )
    product_attributes = db.relationship(
        "ProductAttribute", secondary=product_attribute_product_version, backref="products"
    )


class ProductBrand(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode, nullable=False)
    product_versions = db.relationship("ProductVersion", backref="product_brand")


class ProductCategory(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    parent_id = db.Column(db.BigInteger, db.ForeignKey("product_category.id"))
    name = db.Column(db.Unicode, nullable=False)
    off_name = db.Column(db.Unicode)
    wikidata = db.Column(db.Unicode)
    product_versions = db.relationship("ProductVersion", backref="product_category")
    open_food_facts_categories = db.relationship("OpenFoodFactsCategory", backref="product_category")

class OpenFoodFactsCategory(db.Model):
    #id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode, nullable=False, primary_key=True)
    product_category_id = db.Column(db.BigInteger, db.ForeignKey("product_category.id"))
    product_attributes = db.relationship(
        "ProductAttribute", secondary=product_attribute_open_food_facts_category, backref="open_food_facts_categories"
    )

class ProductAttribute(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode, nullable=False)

class Store(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    store_versions = db.relationship("StoreVersion", backref="store")
    prices = db.relationship("Price", backref="store")


class StoreVersion(db.Model):
    store_id = db.Column(db.BigInteger, db.ForeignKey("store.id"), primary_key=True)
    change_dtm = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, primary_key=True)
    user_id = db.Column(db.BigInteger, db.ForeignKey("user.id"), nullable=False)
    name = db.Column(db.Unicode(80))
    brand_id = db.Column(db.BigInteger, db.ForeignKey("store_brand.id"))
    category_id = db.Column(db.BigInteger, db.ForeignKey("store_category.id"))
    location = db.Column(Geography("POINT"))
    #   Chose BigInteger type because it is used for IDs in OSM's internal schema
    osm_id = db.Column(db.BigInteger)
    #    floor_area Integer
    #   OSM Wiki - 'Commonly used subkeys'
    addr_housenumber = db.Column(db.Unicode)
    addr_housename = db.Column(db.Unicode)
    #    osm addr:flats is not applicable to a single address
    addr_conscriptionnumber = db.Column(db.Unicode)
    addr_street = db.Column(db.Unicode)
    addr_place = db.Column(db.Unicode)
    addr_postcode = db.Column(db.Unicode)
    addr_city = db.Column(db.Unicode)
    addr_country = db.Column(db.Unicode)
    #   OSM Wiki - 'For countries using, hamlet, subdistrict,
    #   district, province, state'
    addr_hamlet = db.Column(db.Unicode)
    addr_suburb = db.Column(db.Unicode)
    addr_subdistrict = db.Column(db.Unicode)
    addr_province = db.Column(db.Unicode)
    addr_state = db.Column(db.Unicode)
    #   OSM Wiki - 'Detailed subkeys'
    addr_door = db.Column(db.Unicode)
    addr_unit = db.Column(db.Unicode)
    addr_floor = db.Column(db.Unicode)
    addr_block = db.Column(db.Unicode)


class StoreBrand(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode, nullable=False)
    store_versions = db.relationship("StoreVersion", backref="store_brand")


class StoreCategory(db.Model):
    #TODO create OSM tag column here and adjust view functions accordingly
    id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode)
    store_versions = db.relationship("StoreVersion", backref="store_category")


class Price(db.Model):
    user_id = db.Column(db.BigInteger, db.ForeignKey("user.id"), nullable=False)
    product_id = db.Column(db.BigInteger, db.ForeignKey("product.id"), primary_key=True)
    store_id = db.Column(db.BigInteger, db.ForeignKey("store.id"), primary_key=True)
    change_dtm = db.Column(db.DateTime, default=datetime.utcnow, primary_key=True)
    #   Made price a Numeric type with 15 places on the left and 5 places
    #   on the right to account for runaway inflation and small
    #   denominations respectively.
    price = db.Column(db.Numeric(15, 5), nullable=False)
    currency_id = db.Column(db.BigInteger, db.ForeignKey("currency.id"), nullable=False)


class Currency(db.Model):
    id = db.Column(db.BigInteger, primary_key=True)
    name = db.Column(db.Unicode, nullable=False)
    iso_4217_alpha_code = db.Column(db.String(3))
    prices = db.relationship("Price", backref="currency")
